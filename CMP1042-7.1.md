# CMP1042-7.1

## Discuss how the application will handle the privacy of user data within the system, and how security features of the frameworks you are utilising will assist to mitigate security concerns.

Example: discuss how the use of ORMs mitigate SQL injection attacks, and how API frameworks such as ExpressJS can handle the sanitisation of user input.

### Privacy of User Data

When sending requests to any of the routes, it is immediately logged by a security package named `morgan`, this package writes to a log file any data pertaining to the client which accessed the route. among the data stored in the log file is the **IP address the request was sent from**, the **time which the route was accessed**, **request details: type, route, and protocol**, the **status code** and **size of the response** from the server, the **URL of the server**, before routes, and the **user agent**, which depicts what type of software the user is accessing the route with. This data is only available locally and is in no way accessible via the database.

Another way I secured the privacy of user data in this API, is that while everyone has access to view user's passwords, the passwords are stored as a SHA-256 hash generated by the `crypto` package.

The API, if running locally, is able to have it's traffic 'sniffed', as it is using an unencoded protocol, HTTP. This could allow users to intercept passwords before they are encoded and stored by the API. A production server would use HTTPS, mitigating this issue.

### Security

#### Misc. Packages

As previously mentioned, the API is using both `morgan` to log detailed information about all requests, and the `crypto` package to avoid storing passwords in plain text, but instead as a SHA-256 hash. This also allows there to be more restrictions placed on the `password` field in the `user` table, as the maximum value a SHA-256 hash can represent in hex is 64, allowing us to use `VARCHAR(64)` as the data type.

Another package I have decided to incorporate into the project is `helmet`. `Helmet` is a package that aims to prevent common vulnerabilities within express servers. `Helmet` is currently configured in my project to control:

- DNS prefetching
- Clickjacking
- X-powered-by Header
- HTTP Strict Transport Security
- X-Download-Options for IE8+
- XSS
- Sniffing of MIME types

#### Express & better-sqlite

Express is the JavaScript web framework that this project hosts it's routes on. Since express is purely a npm package, it becomes very easy to install the package, import it into your file and begin working away. The biggest plus about express is that it is all in JavaScript, allowing you to write your own input validation functions inside the same file, without having to port across multiple platforms or languages. And if you're too lazy to write your own input validation with express, there's npm packages that help to do it, such as `express-validator`,



Better-sqlite is the Object-Relational Mapping (ORM) package that I have opted to use, it is a adapted version of the original `sqlite3` package, but is exponentially faster, and synchronous.

Using an ORM such as better-sqlite allows you to minimise the risk of SQL injection in your database. The main functionality that an ORM provides which allows you to do this is called Parameterized/Prepared queries.



Parameterized or Prepared queries allow a developer to begin writing a query, and notify to the ORM where user input is going to be expected, this allows the ORM to perform special encoding on the user input to treat it as data, not as another statement.

Here's a code example of what a Prepared query would look like in my API:

```javascript
let query = db.prepare(`SELECT * FROM message WHERE author = ?`)
query.all(id)
```

So here we have a SQL query, which will return all data from the `message` table where the `author` is `?`. So what is `?`, `?` is the symbol used in the better-sqlite package to indicate a parameter, something that is varying depending on what the user inputs. So if the user wanted all the messages from user 1, we would store `1` in `id`, set up the prepared query, and run it while providing the parameter, in this case, id.



In summary, for security in this project I'm utilising `morgan` for logging, `crypto` for hashing passwords, `helmet` for configuring lots of things, and preventing others like XSS, `Express` for input validation, and `better-sqlite` for prepared statements.

